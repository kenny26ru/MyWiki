# [Java](#link)

## Core-1
### ООП
> Заметка: 
> 
> 1 - номер главы, 
> 
> 1.1. - номер подтемы,
> 
> 1.1.1. - номер вопроса поддтемы, 
> 
> 1.1.1.1. - номер общего вопроса в wiki 

#### 1.1.1.1. **Что такое ООП?** 

ООП это методология программирования, основанная на описании типов или моделей предметной области, которые взаим-ют друг с другом путем передачи сообщения, тем самым изменяя состояния друг друга. 
Модели описываются в классах, классы могут составлять иерархию, содержать поля - свойства объектов, конструктор и методы.

#### 1.1.2.2. **Преимущества ООП?** 

- Описание моделей предметной области упрощается пониманием этой области. 
- Возможность создавать модели объектов, доступные для пере-использования.
- Возможность создавать расширяемые и масштабируемые системы.

1.1.3.3. **Недостатки ООП?**

- ООП это не серебренная пуля в методологии программирования. Разработка сложной системы сопряжена со значительными затратами интеллектуальных и временных ресурсов.
- Перегрузка объектами: ООП требует распределение информации по множеству мелких инкапсулированных объектов, ссылки на которые растут взрывным темпом. Следовательно падает производительность.
- Сложность: ООП может привести к созданию сложной иерархии классов и взаимосвязи между ними, что усложняет понимание и сопровождение кода. 
- Сложность анализа и тестирования вытекает из создания сложной иерархии классов. 
- Избыточное использование наследования

1.1.4.4. **Основные принципы ООП?** 

- Инкапсуляция,
- Полиморфизм, 
- Наследование,
- Абстракция,

1.1.5.5. **Что такое инкапсуляция?**

- **Инкапсуляция** - сокрытие данных объекта и деталей его реализации от сторонних компонентов системы, предоставление набора функционала для взаимодействие с ним.
    
    - В Java Инкапсуляция реализована с помощью: 

        - Системы классов (в каждом классе собирается информация об объекте),
        - Пакетов, которые группируют классы
        - Модификаторов доступа, которые ограничивают доступ к классу или его элементам.

            - public - полный доступ к сущности
            - protected - доступ для классов наследников и классов в 1 пакете
            - неявный - доступ только для классов 1 пакета
            - private - доступ внутри класса

1.1.6.6. **Что такое наследование?** <a name="link">link</a>

- **Наследование** - принцип ООП, позволяющий создавать иерархию классов (от общего к частному). В одном родительском классе могут быть описаны свойства и поведение для дочерних классов. 

    - Чтобы унаследоваться от класса, используется кл. слово `extends`,
    - Наследование реализует отношение (is - a) "Является",
    - Отсутствует множественное наследование.

```
# General class
public class Animal {
    private int age;
    private String sex;
}

public class Cat extends Animal {
    // specific for Cat
}

public class Dog extends Animal {
    // specific for Dog
}
```

1.1.7.7. **Что такое полиморфизм?**

Полиморфизм вытекает из наследования. Наследуясь от абстрактного класса, мы реализуем и переопределяем методы этого класса в дочерних. 

```
Vehicle vehicle = new SprotCar();
vehicle.start(); ==> Start sportCar 
vehicle = new Truck();
vehicle.start(); ==> Start truck 
```

Бывает:

- динамическим(переопределение),
- статическим(перегрузка).

Статические методы нельзя переопределить, но можно перегрузить. 

Полиморфными бывают: 

- переменная (может принимать значение разных типов),
- метод (если хотя бы 1 аргумент является полиморфной переменной)

1.1.8.8. **Что такое абстракция?**

Абстракция - принцип ООП, позволяющий выделять функционал, без конкретной реализации. 

```
public class Bankomat {
    protected void giveCache(Cache cache);
    protected BigDecimal getOstatok();
    protected Cache getCache(BigDecimal cache);
}
```

1.1.8.8. **Что такое ассоциация, агрегация и композиция?**

**Ассоциация** - отношение независимых друг от друга объектов. "has a" [Иметь] 

Пример: 
>Учитель может преподавать в нескольких классах. Учитель и класс связаны ассоциацией. Но каждый из этих объектов может существовать независимо друг от друга.

**Композиция** - отношение "часть - целое", в котором часть не может отдельно существовать от целого, и, зачастую живет в рамках жизненного цикла целого.

![img.png](images/composition.png)

Пример: 
> Автомобиль состоит из двигателя, колес, кузова и так далее. Если автомобиль уничтожается, все его части (двигатель, колеса и т. д.) тоже уничтожаются. Это композиция, потому что части существуют только в контексте целого.

**Агрегация** - это композиция, только с более слабой связью. В Агрегации часть может существовать вне контекста целого.

![img.png](images/association.png)

Пример:
> Университет состоит из факультетов. Если университет закрывается, факультеты могут продолжать существовать (например, как часть другого университета). Факультеты могут иметь собственный жизненный цикл, не зависящий от университета.

![img.png](images/dependency.png)

![img.png](images/generalization.png)

Наследование "is a" [Являться] (обобщение/расширение) - очень сильная связь 

Пример: 

Вложенный класс - композиция. А вложенный статический класс - агрегация.

1.1.8.9. **Раннее и позднее связывание**

Связывание - означает наличие связей между ссылкой и кодом.

Существуют
* раннее связывание (статическое)

    - Если метод известен компилятору, то происходит ранее связывание на этапе компиляции (early binding) 
    
    - Применяется для: 
      - generics;
      - перегруженных методов;
      - private методов;
      - final методов;
      - static методов;
    - используются не конкретные объекты, а информация о типе (ссылка)

* позднее (динамическое)
    - Происходит во время выполнения программы JVM, какой метод вызвать определяется по объекту

1.1.8.10. **SOLID**

SOLID - принципы разработки ПО, которые направленные на поддержание и масштабирование кода.

S - Single Responsibility Principal - принцип единственной ответственности
> Каждый класс должен иметь только одну зону ответственности

O - Open closed Principal - принцип открытости/закрытости 
> Классы должны быть открытыми для расширения, но закрыты для изменения

L - Liskov substitution Principal - принцип подстановки Барбары Лисков. 
> При подстановки дочернего класса на место родительского, функционал не должен ломаться

I - Interface Segregation Principal - принцип разделения интерфейсов
> Клиент не должен реализовывать интерфейсы, которые не имеют к нему отношения

D - Dependency Inversion Principle - принцип инверсии зависимостей
> Абстракция не должна зависеть от деталей. Детали должны зависеть от абстракции. 
> Модули верхнего уровня не должны зависеть от модулей нижнего. 

1.1.8.11. **Другие принципы разработки**

- DRY (Don't Repeat Yourself) - если участок кода встречается более 2 раз, нужно выносить в отдельный метод
- OR (Occam's Razor) - бритва Оккама - не следует создавать сущности без необходимости в них
- KISS (Keep It Simple Stupid) - делать и использовать только простые и логичные конструкции

### Java

1.2.1.12. **Основная идея языка**

Java - строго типизированный Объектно-Ориентированный язык программирования. 

Реализует принцип **`write once, run anywhere`**

Запускается везде, где есть JRE

Структура JDK

- JDK
  - JAVAC - компилятор
  - lib, doc files, utility
  - JRE
    - JVM
    - Library

- Java code - создаем файл .java
    - JAVAC - код компилируется
      - Byte Code - скомпилированный класс с расширением .class
        - JVM
          - Windows
        - JVM
          - Mac
        - JVM
          - Linux
      
Прочитать байт-код
> javap -v NameFile.class

1.2.2.13. **За счет чего обеспечивается кроссплатформенность?**

За счет виртуальной машины Java (JVM). 

Java Virtual Machine - программа прослойка между ОС и Java. **Нужна для исполнения байт-кода**

1.2.3.14. **Преимущества Java**

1.2.4.15. **Недостатки у Java**

1.2.5.16. **Что такое JDK? Что выходит в него?**

- JDK - пакет инструментов для программирования на Java. JDK - это реализация спецификации платформы Java включающая в себя компилятор и библиотеки классов.
    - JAVAC - компилятор
    - lib, doc files, utility
    - JRE
        - JVM
        - Library

1.2.6.17. **Что такое JRE? Что выходит в него?**

JRE - минимально необходимая реализация виртуальной машины для исполнения

1.2.7.18. **Что такое JVM?**

JVM платформо-зависимы. JVM для Windows не идентична JVM для Linux

1.2.8.19. **Что такое byte-code?**

Это набор инструкций Java, полученный из компилятора, исполняемый JVM. 


1.2.9.20. **Что такое ClassLoader**

https://habr.com/ru/articles/748758/

При загрузке классов JVM загружает в память необходимые классы, проверяет байткод, выделяет необходимые ресурсы и, наконец, выполняет код, преобразуя байткод в инструкцию машинного языка.

![img.png](images/source_code-native_code.png)

3 этапа загрузки классов:
1) загрузка (loading)
2) линковка (link)
3) инициализация (init)

**Загрузка** 

Процесс начинается с того, что ClassLoader получает задание найти определенный класс, что может быть инициировано самой JVM или командой в коде.

Задача: взять полное имя класса (например `java.lang.String`) и получить соответсвующий файл класса (например `String.class`) из его местоположения на диске -> в память JVM.

![img.png](images/class_loading.png)

Принципы скоординированного процесса загрузки класса: 

- Видимость (Visibility) - дочерний ClassLoader видит загруженные классы, но не наоборот. (Инкапсуляция)

- Уникальность (Uniqueness) - дочерний ClassLoader не будет загружать класс, который загружен родительским ClassLoader'ом

- Иерархия делегирования (Delegation Hierarchy) - Application ClassLoader передает запрос Platform ClassLoader и Bootstrap ClassLoader на загрузку класса. Если они не могут найти класс, то запрос передается обратно по цепочке. 

**Bootstrap ClassLoader** - старейший представитель ClassLoader'ов, который грузит классы основные lib из java.base модуля (`java.lang.`, `java.util.`) необходимые для старта JVM.
Bootstrap ClassLoader написан на нативном языке, поэтому загружает в JVM классы

**Platform ClassLoader** - загружает публичные типа системных модулей. Platform ClassLoader пришел на смену Extension ClassLoader, который искал классы в $JAVA_HOME/lib/ext.

**Application ClassLoader** - загружает собственные библиотеки и зависимости, переданные в JVM при старте программы в classpath. Будет являться родителем для собственного загрузчика классов. 

1.2.10.21. **Что такое JIT?**

JIT - технология компиляции, способная генерировать код в машинный на лету. 
JIT-компиляция была создана, что бы решить проблему производительности, связанной с интерпретацией кода во время выполнения программы.


1.2.11.22. **Что такое сборщик мусора?**



1.2.12.23. **Что такое Heap и Stack? Чем они отличаются?**

JVM выделяет 2 области памяти: 
- **область Stack** - хранит примитивы и ссылки на объекты
  - содержит стек фреймы, состоящие из: 
    - параметры метода
    - указатели на предыдущий фрейм
    - локальные переменные

  Stack работает по схеме `LIFO` (Last In First Out) 
  - Особенности Stack:
    - заполняется и освобождается по мере вызова или завершения методов
    - переменные в Stack существуют пока выполняется метод, в котором они были созданы
    - при заполнении памяти в Stack выбрасывается исключение `StackOverFlowError`
    - доступ к Stack быстрее, чем к Heap
    - Stack потокобезопасен, так как для каждого потока создается свой Stack

- **область  Heap** - хранит объекты
  - зависит от реализации GC 
  - Heap реализует динамическое распределение памяти 
  - Размер кучи (Оперативной памяти) в Java 11 и выше - 25% от доступной max = 25 ГБ

  Память в Heap распределена на:
  - Yang Generation - область памяти для недавно созданных объектов. При её заполнении происходит быстрая сборка мусора.
  - Old Generation - хранит долго живущие объекты, при достижении возрастного порога в Yang Generation.
  - Permanent Generation - хранит метаинформацию о классах и методах приложения.

  Особенности Heap:
  - Когда область памяти Heap заполнится, будет выброшено исключение OutOfMemoryError
  - доступ к Heap медленнее, чем к Stack
  - Heap автоматически не освобождается. Для освобождения Heap используется GC 
  - не потокобезопасная


### Процедурная Java

1.3.1.24 **Примитивные типы данных в Java?**

Примитивные типы - тип данных, который определяет диапазон значений, которые может хранить переменная или константа. 

Группы примитивных типов: 
1. Целочисленные - byte, short, int, long
2. Вещественные - float, double
3. Символьные - char
4. Логические - boolean

| Тип, Название | размер байт/бит           | min           | max         | комментарий                                        |
|---------------|---------------------------|---------------|-------------|----------------------------------------------------|
| byte          | 1 byte = 8 bit            | -128<br/>-2^7 | 127<br/>2^7 |                                                    |
| short         | 1 short = 2 byte = 16 bit | -2^15         | 2^15-1      |                                                    |
| int           | 1 int = 4 byte = 32 bit   | -2^31         | 2^31-1      |
| long          | 1 long = 8 byte = 64 bit  |               |             |                                                    |
| float         | 1 float = 4 byte = 32 bit |               |             | 32 bit: знак=1bit, мантиса=23bit, экспонента=8bit  |
| double        | 1 double = 8 byte =       |               |             | 64 bit: знак=1bit, мантиса=52bit, экспонента=11bit |
| char          | 1 char = 2 byte = 16 bit  |               |             | в памяти как числа в диапазоне от 0 до 65 536      |
| boolean       |                           |               |             |                                                    |

Для вычисления денег не используется float или double. Для этого используется BigDecimal

1.3.2.25 **Что такое char** 



1.3.3.26 **Сколько памяти занимает boolean**

В стандартных JVM SUN и Oracle HotSpot тип boolean занимает 4 byte = 32 bit

Приоритет логических операций: 
1. ! Инверсия 
2. & Конъюнкция (умножение)
3. ^ Дизъюнкция (сложение)
4. | Импликация (следование)
5. && Эквиволентность 
6. || 

1.3.4.27 **Что такое классы обертки?**

Классы обертки - классы, которые хранят в себе примитив. Нужны для того, что бы реализовывать generics. 
Являются immutable => при каждой упаковке (за исключением значений из pool) создается новый объект

1.3.5.28 **Что такое автоупаковка и автораспаковка?**

Автоупаковка - процесс преобразования типов в эквивалентные объекты (ссылочные типы).
Автораспаковка - процесс обратный Автоупаковке

Автоупаковка/Автораспаковка не работает для массивов

Благодаря Автораспаковке можно писать выражения, не используя методы конвертации. Этим занимается компилятор Java.

1.3.6.29 **Что такое Явное/неявное приведение типов?**

```
int a = 4;
int b = a; // Ошибка
```
Т.к. мы пытаемся присвоить данные, которые занимают 4 байта переменной, которая занимает 1 байт.

В этом случае нужна операция преобразования типов
```
int a = 4;
int b = (byte) a;
```
Неявное приведение - автоматическое расширение типа переменной от меньшего к большему. 

Старшие разряды более широкого типа заполняются знаковым битом исходного значения.

Явное приведение - явное сужение от большего к меньшему.

В случае с объектами мы можем делать неявное автоматическое приведение от `наследника` к `родителю`, но не наоборот, иначе `ClassCastException`.

Приведение с потерей точности: 
int => float
long => float

long - 64 бита, из которых 63 отводится на точность под число, 
float - 32 битное число, у которого на точность отводится ~24 бита, 
double - 64 бита, у которого на точность отводится ~53 бита. 

То есть даже приводя long в double есть риск потерять точность!

При приведении данных с плавающей точкой к целочисленным значениям происходит усечение дробной части
```
doutble a = 56.9999;
int b = (int) a; // => 56 
```

Что бы не допустить такого, нужно применять методы из пакета Math, метод round:
```
doutble a = 56.9999;
int b = Math.round(a); // => 57
```
Большое дробное число при приведении к целому превращается в MAX_VALUE / MIN_VALUE
Большое число double при приведении к float превращается в Float.POSITIVE_INFINITY / Float.NEGATIVE_INFINITY

Вопрос:`Какой результирующий тип получим при сложении char и short? `
Ответ: int, потому что char и short автоматически расширяется до int

1.3.7.30 **Что такое pool интов?**
```
Integer i1 = 10;
Integer i2 = 10;
System.out.println( i1 == i2 ); // true
```

```
Integer i1 = 130;
Integer i2 = 130;
System.out.println( i1 == i2 ); // false
```
В Java есть пул целых чисел в промежутке от -128 до 127. Т.е. если мы создаем Integer в этом промежутке, то вместо того, что бы создавать каждый раз новый объект, JVM берет их из пула.

```
Integer i1 = new Integer(10);
Integer i2 = new Integer(10);
System.out.println( i1 == i2 ); // false
```
Кэширование/Integer pool: 
Когда мы присваиваем переменной типа Integer значение типа int, при этом вызывается метод Integer.valueOf(int): 

`Integer x = 5;` => `Integer x = Integer.valueOf(5);`

В классе обертке Integer есть внутренний класс `IntegerCache`.
Он объявлен как private static. В этом внутреннем классе кэшированные объекты находятся в массиве `cache[]`.

Кэширование выполняется при первом использовании класса обертки. После первого использования, вместо создания нового экземпляра (кроме использования конструктора) используются кэшированные объекты
Код метода valueOf класса Integer:
```
public static Integer valueOf(int i) {
    if ((i >= IntegerCache.low) && (i <= Integer.high) )
        return Integer.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```
Аналогично IntegerCache существуют ByteCache, ShortCache, LongCache, CharacterCache.

При использовании new кэширование не работает.

1.3.8.31 **Какие нюансы у строк в Java?**

String - строка символов. 

Переменная ссылочного типа - ячейка памяти, содержащая ссылку на ячейку памяти, в которой лежит объект. 

Когда присваиваем значение 1 ссылочной переменной другой или передаем её в качестве параметра в метод, выполняется копирование ссылки.

Если через вторую ссылку объект меняется, то изменения видны и через 1 ссылку. 

String - Immutable, final class в Java. Поэтому все манипуляции со строкой будут создавать новую строку.

Неизменяемость строк реализовована с помощью final, private, нет сеттеров. 

1.3.9.32 **Что такое пул строк?**

String pool - специальный массив для хранения строк в памяти Heap. 

Пул строк - набор строк, который хранится в памяти Java heap

Когда мы создаем строку используя `" "`, JVM ищет в пуле строк другую строку с таким же значением. Если строка найдена, то возвращается только ссылка на существующий объект,
класса String, иначе сохраняется новый объект с полученным значением и сохраняется в пул.

Когда мы используем оператор new виртуальная машина создает объект String, но не хранит его в пуле строк. Метод `intern()` используется для сохранения строки в пул или получения ссылки, если такая строка уже лежит в пуле.
```
String s1 = "CAT";
String s2 = "CAT";
String s3 = new String("CAT");

System.out.println( s1 == s2 ); // true
System.out.println( s1 == s3 ); // false
```

> Пул строк реализован на основе паттерна "Приспособленец". Это структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым



1.3.10.33 **Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?**

Строка является неизменной и финализированной в Java, поэтому все манипуляции приведут к созданию новых строк, что 
является ресурсоемким. 

Для манипуляций со строками рекомендуется использовать `StringBuilder` или `StringBuffer`. 

Операции со StringBuffer потоко-безопасны и синхронизированы, в отличная от StringBuilder. 

В многопоточной среде нужно использовать StringBuffer, в одно-поточной среде StringBuilder, так как он более производительный. 

1.3.11.34 **Почему строки не рекомендуется хранить для хранения паролей?** 

Строка неизменяемая в Java и хранится в пуле строк. С тех пор как она была создана, она остается в пуле, до тех пор, 
пока сборщик мусора не удалит её. <br>
Поэтому когда мы заканчиваем работу с паролем, строка какое-то время остается доступной в памяти. Это несет в себе риск
слива данных тому, кто имеет доступ к дампу памяти, <br> так как он может достать пароль в чистом тексте. 

Если мы используем массив символов для хранения пароля, мы сможем отчистить его, после того, как закончим с ним 
работать. Таким образом, мы можем контролировать, как долго он находится в памяти. 


1.3.12.35 **Почему String неизменяемый и финализированный класс?**



1.3.13.36 **Почему String чаще всего используют в качестве ключа для HashMap**

У изменяемых объектов хэшкод изначально равен 0 и он таков до тех пор, пока мы не вызвали метод `hash()`, после этого 
сгенерируется хэш-значение - в момент получения кода.

Поскольку String неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. 

1.3.14.37 **Что делает метод intern() в классе String?**

При вызове метод `intern()` возвращает строку, эквивалентную сроке, хранящейся в пуле строк (проверка по `equals()`). 
Иначе строка добавляется в пул и возвращается ссылка на эту строку.

```
String s1 = "Hello Word";
String s2 = "Hello Word"
String s3 = new String(""Hello Word"").intern();
String s4 = new String(""Hello Word"").intern();

System.out.println("Строка 1 равна строке 2 " + (s1 == s2)); => Строка 1 равна строке 2 true
System.out.println("Строка 2 равна строке 3 " + (s2 == s3)); => Строка 2 равна строке 3 true
System.out.println("Строка 3 равна строке 4 " + (s3 == s4)); => Строка 3 равна строке 4 true
```
Без метода `intern()`
```
String s1 = "Hello Word";
String s2 = "Hello Word"
String s3 = new String(""Hello Word"");
String s4 = new String(""Hello Word"");

System.out.println("Строка 1 равна строке 2 " + (s1 == s2)); => Строка 1 равна строке 2 true
System.out.println("Строка 2 равна строке 3 " + (s2 == s3)); => Строка 2 равна строке 3 false
System.out.println("Строка 3 равна строке 4 " + (s3 == s4)); => Строка 3 равна строке 4 false
```

1.3.15.38 **Можно ли использовать String в конструкции switch?**

В Java 7 расширены возможности использования switch для строк. Ранние версии Java не поддерживают этого.

Ключевые моменты использования switch для String в Java:
- делает код читабельнее, убирая множественные цепи условий if-else
- строки в switch чувствительны к регистру
- оператор switch использует метод `String.equals()` для сравнения значения, полученного в case, поэтому нужна проверка 
на NULL, что бы избежать NPE
- согласно документации Java 7 компилятор Java использует более эффективный байткод для строк в конструкции switch, 
чем для условий if-else
- до Java 7 использование строк в switch приведет к Exception

1.3.16.39 Какая основная разница между String, StringBuffer и StringBuilder?

- String является неизменяемой и финализированной, поэтому все манипуляции ресурсоемкие и приведут к созданию новой 
строки 
- StringBuffer потоко-безопасен и синхронизирован
- StringBuilder производительный за счет отсутствия синхронизаций, но потоко-небезопасен

1.3.17.40 **Существуют ли в Java многомерные массивы?**

В классическом понимании многомерных массивов в Java не существует.

Многомерный массив всегда прямоугольный и неразрывен в памяти.

То, что в Java считается многомерным в других ЯП называется зубчатым или массивом массивов. 

Пример многомерного массива в java:
```
int[][] array = new int[3][4]
```

1.3.18.41 **Какими значениями инициируются переменные по умолчанию?**


1.3.19.42 **Что такое сигнатура метода?**

Сигнатура метода - это имя метода плюс параметры (порядок параметров имеет значение). В сигнатуру метода не входят 
возвращаемое значение и бросаемые исключения.

Контракт метода - это тип возвращаемого значения, имя + параметры метода + бросаемое исключение.

1.3.20.43 **Расскажите про метод main?**

Метод main является точкой входа программы. В классе может быть несколько методов main, но только 1 метод может быть 
запускающим. 

1.3.21.44 **Каким образом переменные передаются в методы, по значению или по ссылке?**

Примитивы передаются по значению, объекты по ссылке.

### ООП в Java

1.4.1.45 **Какие виды классов есть в Java?**

Классы в Java:
- class:
  - обычные 
  - абстрактные
  - финализированные
- Interface
- Enum
- Nested class - Вложенный класс - любой класс, объявление которого происходит в теле другого класса или интерфейса.
  - static
  - inner
  - anonymous
- Sealed types (Java 15) - изолированные типы или запечатанные классы - классы и интерфейсы, которые могут запрещать 
наследовать или реализовывать себя.

Изолированный класс или интерфейс может быть наследуемым или реализованным только теми классами, которым это разрешено.


1.4.2.46 **Вложенные классы и в каких случаях применяются?**

Вложенный класс - класс определенный внутри другого класса. 

Вложенный класс предназначен для обслуживания класса верхнего уровня, если он становится нужным вне класс, внутри 
которого он обозначен, то его стоит вынести на верхний уровень. 

Вложенный класс имеет доступ ко всем приватным полям и методам, но не наоборот. Из-за этого разрешение использования 
вложенных классов приводит к нарушению инкапсуляции.

1.4.3.47 **Что такое локальный класс? Каковы его особенности?**

Local inner class (Локальный класс) - это вложенный класс, который может быть декларирован в любом блоке и в котором 
разрешается декларировать переменные.

Особенности:
- видны только в пределах блока, в котором объявлены
- не могут быть объявлены как private/public/protected/static
- не могут иметь внутри себя статических объявлений (полей, методов, классов)
- имеют доступ к полям и методам класса верхнего уровня
- могут обращаться к локальным переменным и параметрам, если они объявлены с модификатором final

1.4.4.48 **Что такое анонимные классы? Где применяются?** 

Анонимный класс - вложенный локальный класс без имени, который разрешено декларировать в любом месте верхнего класса.

Создание экземпляра аноним класса происходит в момент объявления класса. 

Ограничения аноним класса: 
- использование разрешено только в месте его создания.
- применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться.
- реализует лишь методы своего интерфейса или суперкласса.

Применяются для:
- создания объекта функции (function object - например реализация интерфейса Comparator)
- создание объекта процесса (process object - например экземпляр классов Thread, Runnable и подобных)
- в статическом методе генерации
- инициализация открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого
экземпляра в перечислении требуется отдельный подкласс
```
public enum ComplexEnum {
    TYPE_A {
        @Override
        public String getTypeName() {
            return "TYPE_A";
        }
    },
    TYPE_B {
        @Override
        public String getTypeName() {
            return "TYPE_B";
        }
    },
    TYPE_C {
        @Override
        public String getTypeName() {
            return "TYPE_C";
        }
    };
    
    public abstract String getTypeName();
}
```

1.4.5.49 **Каким образом из вложенного класса получить доступ к полю внешнего класса?**

static inner class имеет доступ только к static полям.

Простой inner class может обратиться к любому полю внешнего класса напрямую. 

1.4.6.50 **Что такое Enum?**

Enum - специальный тип данных, который позволяет переменным быть набором предопределенных констант.

Методы для enum: 
- name() - возвращает имя элемента
- ordinal() - возвращает порядковый номер
- values() - возвращает массив возможных значений перечислений в порядке записи
- методы класса Object

1.4.7.51 **Как проблема ромбовидного наследования решена в java?**

Java не поддерживает множественное наследование в классах, но поддерживает в интерфейсах. 1 интерфейс может расширять
множество других интерфейсов.

Это работает, потому что интерфейсы только объявляют методы, а реализация методов ложится на классы, которые 
имплементируют интерфейс. 

1.4.8.52 **Что такое конструктор по умолчанию?**

Конструктор без входных параметров, но если определить конструктор, то конструктор по умолчанию затрется. 

1.4.9.53 **Приватные конструкторы, для чего нужны?**

Приватные конструкторы запрещают создание экземпляра вне методов самого класса.

1.4.10.54 **Классы загрузчики и динамическая загрузка классов?**

Существует 3 стандартных загрузчиков класса:
- Bootstrap (базовый загрузчик) загружает стандартные классы JDK из архива rt.jar
- Extension загружает классы из пакета lib/ext из JRE 
- System загружает классы приложения, определенные в переменной среде окружения java.class.path 

Иерархия: Bootstrap -> Extension -> System

Каждый загрузчик имеет указатель на родительский classloader, что бы иметь возможность делегировать загрузку классов.

Принципы делегирования:

- Принцип делегирования: если загрузчик не нашел классы для загрузки, загрузка классов передается родительскому лоадеру. 
Этот подход позволяет загружать классы находящиеся максимально близко к лоадеру, обеспечивая максимальную видимость 
классов.

- Принцип видимости: загрузчик видит только свои и родительские классы, не знает про классы, загруженные потомком.

- Принцип уникальности: класс может быть загружен только 1 раз.

Возможные исключения: ClassNotFoundException / NoClassDefFoundException

Модель динамической загрузки: 
- классы загружаются только тогда, когда используются(некоторые базовые классы загружаются при старте приложения)

Любая JVM включает в себя classLoader. Исходя из спецификаций Java Standard Edition, что бы получить работающий код 
необходимо выполнить 3 этапа:
- загрузка байт-кода и создание экземпляров класса
  - поиск класса среди загруженных ранее классов
  - получение байт-кода класса для загрузки
  - проверка коррекности байт-кода
  - создание экземпляра класса
  - загрузка родительских классов

Если родительские классы и интерфейсы не были загружены, то нужный класс считается не загруженным!

- линковка или связывание, делится на 3 этапа:
  - верификация: проверка корректности байт-кода
  - подготовка: вы


... Дописать


1.4.11.55 **Чем отличаются конструкторы по умолчанию, конструкторы компирования и конструкторы с параметрами?**

Конструктор по умолчанию не принимает аргументы.
Конструктор с параметрами принимает аргументы.
Конструктор копирования принимает в качестве аргумента экземпляр текущего класса.




## Core-2
## Многопоточность













# SQL

**Виды JOIN'ов**

**JOIN** - оператор, который используется для объединения строк из 2 и более таблиц на основе связующего столбца между ними. Такой столбец называется ключом.
- Внутреннее соединение **INNER JOIN** - в результате запроса попадут только те записи, для которых выполняется условия объединения
    ```
        SELECT column_name
        FROM table1
        INNER JOIN table2 
        ON table1.column_name = table2.column_name
    ```
  ![img.png](images/inner_join.png)

- Внешнее соединение OUTER JOIN - в результате запроса попадут не только записи с совпадениями в обеих таблицах, но и записи 1 из таблиц целиком.
    Указание таблицы, из которой нужно выбрать все записи без фильтрации называется направлением соединения. 
  - LEFT OUTER JOIN / LEFT JOIN


# Hibernate
# Паттерны
# Алгоритмы

Алгоритм - набор инструкций для выполнения некоторой задачи.

**Бинарный поиск**:

Бинарный поиск - это алгоритм, использующий отсортированный список из `n` элементов, скорость поиска которого log2(n). 
Для списка из 8 элементов потребуется не более 3 попыток, что бы найти элемент.
Сложность выполнения алгоритма O(log n) - логарифмическое.

O-большое описывает скорость работы алгоритма, помогает определить, как возрастает время выполнения алгоритма с увеличением размера списка.




# Микросервисы
# Kafka


# Health Checks

В распределенных системах требуются механизмы наблюдения и мониторинга в режиме рантайма.

Почему мы используем Health Checks?

**Health Checks функции сообщают нам о статусе приложений, например, если сервис медленный или не доступен.**

# Система сборки проектов

## Maven

**Жизненный цикл**

1. clean

2. validation - фаза проверки корректности проекта перед сборкой. Maven проверяет, существует ли все необходимые файлы и ресурсы, а также соответствует ли проект определенным стандартам и правилам

3. compile - фаза компиляции исходных файлов проекта, написанных на Java, в байт-код. Все скомпилированные файлы помещаются в target/classes.

4. test - фаза запуска тестов с использованием фреймворков JUnit или TestNG. Maven выполняет все тесты из директории src/test/java и сообщает о результатах. Если тест проваливается, сборка прерывается. 

5. package - фаза, в которой Maven упаковывает скомпилированные файлы и ресурсы в дистрибутивный формат, определенный типом проекта. JAR / WAR

6. verify - фаза дополнительной проверки результатов сборки. Например, проверяется, что все необходимые ресурсы и зависимости были включены в собранный артефакт.

7. install - фаза, в которой Maven устанавливает собранный артефакт в локальный репозиторий. Это позволяет использовать артефакт в других проектах, без необходимости повторной сборки

8. deploy - копирует собранный артефакт в удаленный репозиторий
