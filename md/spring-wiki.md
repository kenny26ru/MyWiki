### 1. Из каких основных сущностей состоит Spring-приложение?

- ApplicationContext - основное хранилище для контекста приложение, не изменяется, но может быть перегружен.
    - BeanFactory - главная точка входа в DI-контейнер. Хранит в себе BeanDefinition'ы, создает по ним экземпляры bean
      или выдает существующие, в зависимости от скоупа бинов.
        - BeanDefinitionReader - используется для создания BeanDefinition, некоторые вызываются из контекста, а
          некоторые реализуют BeanFactoryPostProcessor.
        - BeanFactoryPostProcessor - пост обработчик для BeanDefinition. В нем донастраивается бин или класс, который
          создает бин.
        - BeanDefinition - декларация, описание того, как создавать bean, хранит в себе его тип, метаинформацию и набор
          параметров для конструктора
        - BeanPostProcessor - донастраивает созданные бины, перед тем, как положить их в контейнер. Они лежат в
          BeanFactory. В них можно оборачивать бины в прокси.
    - Bean - объект бизнес логики в Spring Framework
    - ResourceLoader (файлы ресурсов)
    - MessageSource (локализованные сообщения)

```
public interface MessageSource {
    @Nullable
    String getMessage(String var1, @Nullable Object[] var2, @Nullable String var3, Locale var4);

    String getMessage(String var1, @Nullable Object[] var2, Locale var3) throws NoSuchMessageException;

    String getMessage(MessageSourceResolvable var1, Locale var2) throws NoSuchMessageException;
}
```

- ApplicationEventPublisher
- ApplicationEvent
- ApplicationListener

ApplicationContext выполняет 4 разных обязанности:

1. DI-контейнер. ApplicationContext функционирует как специальная реализация BeanFactory. Контексты составляют иерархию,
   определение бинов в дочерних классах перекрывают определение в родительских.
2. Загрузка ресурсов. Под интерфейсом ResourceLoader загружаются классы из classpath и в целом из файловой системы.
3. Публикация событий. Контекст распространяет в приложении события - наследники ApplicationEvent. Любой бин, который
   должен получать события реализует интерфейс ApplicationListener (паттерн Наблюдатель).
4. Интернационализация. По коду, набору аргументов и локали через интерфейс MessageSource можно получать локализованные
   текстовые сообщения для пользователей.


- Web Layer
    - Spring Hateoas
        - HATEOAS (Hypermedia As The Engine Of Application State) [Гипермедие как двигатель состояния приложения] -
          проект Spring, упрощающий создание RESTful API. Принцип HATEOAS предполагает, что API должно предоставлять
          информацию о
          том, какие действия доступны клиенту, основываясь на текущем состоянии ресурса.

            - Основные цели и преимущества Spring Hateoas:

                1. Поддержка принципа Spring Hateoas:
                   HATEOAS - часть архитектурного стиля REST, который подразумевает, что клиент взаимодействует с API,
                   основываясь на
                   гипермедийных ссылках, которые предоставляет сервер. Клиент не должен знать заранее, как
                   взаимодействовать с API, а
                   должен следовать ссылкам и инструкциям, предоставленным сервером.
                2. Упрощение управления ресурсам:
                   Spring Hateoas предоставляет удобные способы для создания и управления ресурсами с помощью
                   гипермедийных ссылок, что
                   позволяет:
                    - Легко добавлять ссылки к ресурсам в ответах API
                    - Упрощать навигацию между различными ресурсами и состояниями.
                    - обеспечить само описательность API
                3. Интеграция с Spring Framework:
                   Spring Hateoas интегрируется с Spring MVC и Spring Data, что позволяет лего добавлять
                   функциональность Hateoas в существующие приложения. Это включает в себ:
                    - Использование аннотаций для создания ссылок в контроллерах
                    - Поддержку Hateoas в репозиториях и сервисах, упрощая создание ссылок на связанные ресурсы.
                4. Снижение зависимости клиента от сервера:
                   Поскольку сервер предоставляет ссылки на доступные действия, клиент становится менее зависимым от
                   конкретной структуры URL и API, что позволяет более гибко изменять API без необходимости обновления
                   клиентов
                5. Улучшение документации и тестирования:
                   Использование Spring Hateoas может улучшить документацию и API, так как ссылки и доступные действия
                   автоматически документируются. Это также упрощает тестирование, так как поведение API становится
                   более предсказуемым.

Зачем нужен HATEOAS? - слабая связь (loose coupling).

- Spring Mobile
- Spring Web Flow
- Spring Session
- Spring Web Services
- Spring Social
- Spring For Android
- Common Layer
    - Spring Test
    - Spring Data Access
    - Spring Messaging
    - Spring Core
    - Container
    - Spring AOP
    - Spring Web
- Service Layer
    - Spring Cloud
    - Spring Integration
- Data Layer
    - Spring LDAP
    - Spring AMQP
    - Spring DATA
    - Spring Batch
- Spring Boot
- Spring XD

### 2. Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)?

### 3. Как эти принципы реализованы в Spring?

### 4. Что такое IoC-контейнер?

### 5. Что такое Bean в Spring?

### 6. Расскажите про аннотацию @Bean?

### 7. Расскажите про аннотацию @Component?

### 8. Чем отличаются аннотации @Bean и @Component?

### 9. Расскажите про аннотации @Service и @Repository? Чем они отличаются?

### 10. Расскажите про аннотацию @Autowired?

### 11. Расскажите про аннотацию @Resource?

`@Resource` может применяться к классам, полям и методам

```
@Resource(name = "fileName")
private File defaultFile;
```

@Resource пытается получить зависимость

- сперва по имени
    - Имя берется из аннотируемого поля или сеттера, либо из параметра name. При аннотировании класса имя не
      извлекается, поэтому оно должно быть указано явно.
- потом по типу
- затем по описанию @Qualifier

Указав данную аннотацию у полей или методов с аргументом `name`

### 12. Расскажите про аннотацию @Inject ?

### 13. Расскажите про аннотацию @Lookup ?

### 14. Как работает инъекция прототипа в singleton ?

Допустим ситуацию, когда в singleton-компонент внедряется зависимость со scope prototype - когда будет создан её объект?

Если добавить к определению бина аннотацию `@Scope(SCOPE_PROTOTYPE)` и использовать этот бин в синлтоне через аннотацию
`@Autowired` - будет создан только 1 объект.

Простой способ получать новый объект при каждом обращении - отказаться от `@Autowired` и доставать его из контекста
вручную, вызывая `context.getBean(MyPrototype.class)`.

Воспользоваться автоматическим внедрением зависимостей можно через внедрение метода (паттерн "Команда"). Внедряется не
сам объект, а производящий его метод.

**Более красивый декларативный способ - правильно настроить определение бина.**

В аннотации `@Scope` кроме самого `scopeName` доступен параметр `proxyMode`.

По умолчанию его значение `NO` - прокси не создается. Но если указать `INTERFACES` или `TARGET_CLASS`, то
под `@Autowired` будет внедряться не сам объект, а его сгенерированный фреймворком прокси.

И когда проксируемый бин имеет `scope prototype`, то объект внутри прокси будет пересоздаваться при каждом обращении.

(Дописать пример!!!)

### 15. Можно ли вставить бин в статическое поле? Почему ?

### 16. Расскажите про аннотации @Primary и @Qualifier ?

### 17. Как заинжектить примитив ?

### 18. Как заинжектить коллекцию ?

### 19. Расскажите про аннотацию @Conditional ?

### 20. Расскажите про аннотацию @Profile ?

### 21. Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать ?

### 22. Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy ?

### 23. Расскажите про скоупы бинов? Какой скоуп используется по умолчанию ?

### 24. Расскажите про аннотацию @ComponentScan ?

### 25. Как спринг работает с транзакциями ?

### 26. Расскажите про аннотацию @Transactional ?

### 27. Расскажите про аннотации @Controller и @RestController. Чем они отличаются ?

### 28. Как вернуть ответ со своим статусом (например, 213) ?

### 29. Что такое ViewResolver ?

### 30. Чем отличаются Model, ModelMap и ModelAndView ?

### 31. Расскажите про паттерн Front Controller, как он реализован в Spring ?

### 32. Что такое AOP? Как реализовано в спринге ?

### 33. PROXY что это, для чего и как применяется в Spring ?

### 34. В чем разница между Filters, Listeners and Interceptors ?

### 35. Можно ли передать в запросе один и тот же параметр несколько раз? Как ?

### 36. Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются ?

### 37. Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно ?

### 38. Какие задачи решает Spring Data? ?

### 39. Какова иерархия интерфейсов/классов репозитория в Spring Data JPA ?

### 40. Как преодолеть проблему блокирующих вызовов ?

### 41. Как вызвать транзакционный метод из того же класса ?

### 42. Когда отрабатывает @Autowired а когда @Transactional? почему? Почему нельзя отработать @Transactional в другом методе ?

### 43. Структура HTTP запроса, ответа ?

### 44. HTTP методы ?

### 45. Ключевое отличие методов POST и GET ?

### 46. REST стиль ?

### 47. Идемпотентность: что это такое, методы ?

### 48. Как метод пост сделать идемпотентным ?

### 49. ?

### 40. ?

### 41. ?

### 42. ?

### 43. ?

### 44. ?

### 45. ?

### 46. ?

### 47. ?

### 48. ?

### 49. ?

### 50. ?

### 51. ?

### 52. ?

### 53. ?

### 54. ?

### 55. ?

### 56. ?

### 57. ?

### 58. ?

### 59. ?

### 39. ?