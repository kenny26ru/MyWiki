### 1. Из каких основных сущностей состоит Spring-приложение?

- `ApplicationContext` - основное хранилище для контекста приложение, не изменяется, но может быть перегружен.
    - `BeanFactory` - главная точка входа в DI-контейнер. Хранит в себе BeanDefinition'ы, создает по ним экземпляры bean
      или выдает существующие, в зависимости от скоупа бинов.
        - `BeanDefinitionReader` - используется для создания BeanDefinition, некоторые вызываются из контекста, а
          некоторые реализуют BeanFactoryPostProcessor.
        - `BeanFactoryPostProcessor` - пост обработчик для BeanDefinition. В нем донастраивается бин или класс, который
          создает бин.
        - `BeanDefinition` - декларация, описание того, как создавать bean, хранит в себе его тип, метаинформацию и
          набор
          параметров для конструктора
        - `BeanPostProcessor` - донастраивает созданные бины, перед тем, как положить их в контейнер. Они лежат в
          BeanFactory. В них можно оборачивать бины в прокси.
    - `Bean` - объект бизнес логики в Spring Framework
    - `ResourceLoader` (файлы ресурсов)
    - `MessageSource` (локализованные сообщения)

```
public interface MessageSource {
    @Nullable
    String getMessage(String var1, @Nullable Object[] var2, @Nullable String var3, Locale var4);

    String getMessage(String var1, @Nullable Object[] var2, Locale var3) throws NoSuchMessageException;

    String getMessage(MessageSourceResolvable var1, Locale var2) throws NoSuchMessageException;
}
```

- ApplicationEventPublisher
- ApplicationEvent
- ApplicationListener

ApplicationContext выполняет 4 разных обязанности:

1. DI-контейнер. ApplicationContext функционирует как специальная реализация BeanFactory. Контексты составляют иерархию,
   определение бинов в дочерних классах перекрывают определение в родительских.
2. Загрузка ресурсов. Под интерфейсом ResourceLoader загружаются классы из classpath и в целом из файловой системы.
3. Публикация событий. Контекст распространяет в приложении события - наследники ApplicationEvent. Любой бин, который
   должен получать события реализует интерфейс ApplicationListener (паттерн Наблюдатель).
4. Интернационализация. По коду, набору аргументов и локали через интерфейс MessageSource можно получать локализованные
   текстовые сообщения для пользователей.


- Web Layer
    - Spring Hateoas
        - HATEOAS (Hypermedia As The Engine Of Application State) [Гипермедие как двигатель состояния приложения] -
          проект Spring, упрощающий создание RESTful API. Принцип HATEOAS предполагает, что API должно предоставлять
          информацию о
          том, какие действия доступны клиенту, основываясь на текущем состоянии ресурса.

            - Основные цели и преимущества Spring Hateoas:

                1. Поддержка принципа Spring Hateoas:
                   HATEOAS - часть архитектурного стиля REST, который подразумевает, что клиент взаимодействует с API,
                   основываясь на гипермедийных ссылках, которые предоставляет сервер. Клиент не должен знать заранее,
                   как взаимодействовать с API, а должен следовать ссылкам и инструкциям, предоставленным сервером.
                2. Упрощение управления ресурсам:
                   Spring Hateoas предоставляет удобные способы для создания и управления ресурсами с помощью
                   гипермедийных ссылок, что
                   позволяет:
                    - Легко добавлять ссылки к ресурсам в ответах API
                    - Упрощать навигацию между различными ресурсами и состояниями.
                    - обеспечить само описательность API
                3. Интеграция с Spring Framework:
                   Spring Hateoas интегрируется с Spring MVC и Spring Data, что позволяет лего добавлять
                   функциональность Hateoas в существующие приложения. Это включает в себ:
                    - Использование аннотаций для создания ссылок в контроллерах
                    - Поддержку Hateoas в репозиториях и сервисах, упрощая создание ссылок на связанные ресурсы.
                4. Снижение зависимости клиента от сервера:
                   Поскольку сервер предоставляет ссылки на доступные действия, клиент становится менее зависимым от
                   конкретной структуры URL и API, что позволяет более гибко изменять API без необходимости обновления
                   клиентов
                5. Улучшение документации и тестирования:
                   Использование Spring Hateoas может улучшить документацию и API, так как ссылки и доступные действия
                   автоматически документируются. Это также упрощает тестирование, так как поведение API становится
                   более предсказуемым.

Зачем нужен HATEOAS? - слабая связь (loose coupling).

- Spring Mobile
- Spring Web Flow
- Spring Session
- Spring Web Services
- Spring Social
- Spring For Android
- Common Layer
    - Spring Test
    - Spring Data Access
    - Spring Messaging
    - Spring Core
    - Container
    - Spring AOP
    - Spring Web
- Service Layer
    - Spring Cloud
    - Spring Integration
- Data Layer
    - Spring LDAP
    - Spring AMQP
    - Spring DATA
    - Spring Batch
- Spring Boot
- Spring XD

### 2. Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)?

**IoC** - делегирование создания и управления объектами. Т.е. передача программистом прав на создание и управление
объектами Spring'у.

**DI** - делегирование добавления/внедрения зависимостей. DI делает объекты нашего приложения слабо зависимыми друг от
друга.

**Инверсия контроля (Inversion of control)** - принцип управления, по которому контроль над потоком управления
передается фреймворку. При разработке модуля этот подход избавляет от необходимости знать о других модулях программы и
деталях их взаимодействия.

### 3. Как эти принципы реализованы в Spring?

Spring состоит из набора библиотек, основная из которых, Spring IoC, реализует DI.

- Inversion of control
    - Способы конфигурации:
        - XML file (устаревший способ)
        - Annotations + XML file (современный способ)
        - Java code (современный способ)
- Dependency injection
    - Способы внедрения зависимостей:
        - конструктор
        - сеттер
        - Autowired

### 4. Что такое IoC-контейнер?

Контейнер в Spring Framework отвечает за создание, настройку и сборку объектов - бинов, а также за управление их
жизненным циклом.

Представляет собой интерфейс ApplicationContext.

Под капотом представляет собой ассоциативный массив, где ключ - String идентификатор, значение - объект, который
создается IoC посредством вызова его конструктора (с помощью reflection api), с последующим внедрением зависимости.

Spring Framework предоставляет несколько реализаций ApplicationContext:

- ClassPathXmlApplicationContext и FileSystemApplicationContext для автономных приложений
- WebApplicationContext для web приложений
- AnnotationConfigApplicationContext для обычной java конфигурации, в качестве аргумента которому передается класс, либо
  список классов с аннотацией @Configuration, @Component

Контейнер собирает инструкции для создания бина через метаданные.

- через xml:
- java annotation: начиная с Spring 2.5, поддержка метаданных конфигурации и аннотации на основе байт кода,
- Java Code: начиная со Spring 3.0 можно определять настройки бина в классах помеченных аннотациями @Configuration,

### 5. Что такое Bean в Spring?

Объект, который управляется фреймворком.
Для его создания и получения, сперва нужно создать ApplicationContext

### 6. Расскажите про аннотацию @Bean?

@Bean - это настройка над методом, которая создает, настраивает и инициализирует новый бин.

Методы с аннотацией @Bean можно использовать в классах конфигурации помеченные @Configuration, а также @Component.

@Bean дополнительно позволяет настроить параметр:

- name - имя бина
- value
- initMethod - имя метода при инициализации бина
- destroyMethod - имя метода
- autowireCandidate - является ли этот бин кандидатом на автоматическое внедрение

### 7. Расскажите про аннотацию @Component?

@Component - простой способ указать на класс, который будет создавать Spring-bean.

Из всех классов, которые попали в область видимости @ComponentScan, будут созданы декларации бинов Bean Definition.

@Service, @Repository, @Controller - это алиасы аннотации @Component.
Поведения не добавляют, но разделяют работу с кодовой базой на слои.

Эти аннотации называют Stereotype annotations, главное различие - семантика, логическая роль компонентов.

- @Service - реализация бизнес логики.
- @Repository - хранилище/слой данных
- @Controller - обработка web запросов.

### 8. Чем отличаются аннотации @Bean и @Component?

@Component (как @Service и @Repository) используется для автоматического обнаружения и автоматической настройки бинов в
ходе сканирвоания путей к классам.

@Bean используется для явного объявления бина, а не для того, чтобы Spring делал это автоматичски

с @Bean можно:

- вручную создать бин,
- объявить бин, независимо от объявления класса, что позволяет использовать классы из сторонних библиотек, у которых не
  можем указать аннотацию @Component
- можем настроить инит и дестрой методы, автовайев кандидат, делая процесс создания бина гибким

### 9. Расскажите про аннотации @Service и @Repository? Чем они отличаются?

@Service и @Repository являются частными случаями аннотации @Component.

@Service используется в сервисном слое, отвечающем за бизнес логику.

@Repository - предоставляет механизм для CRUD операций. Также отлавливает определенные исключения персистентности (
Persistence Exception) и пробрасывает их как одно непроверяемое исключение Spring Framework. Для этого в контексте
должен быть добавлен класс PersistenceExceptionTranslationPostProcessor.

### 10. Расскажите про аннотацию @Autowired?

@Autowired - используется для внедрения зависимостей, помечается на конструкторе, сеттере, поле, методе-конфигурации.

За обработку @Autowired отвечает BeanPostProcessor.

Фактически внедрение выполняется через BeanPostProcessor, что означает, что нельзя использовать @Autowired для внедрения
ссылок в типы BeanPostProcessor или BeanFactoryPostProcessor.

Наличие аннотации проверяется классом `AutowiredAnnotationBeanPostProcessor`.

Начиная со Spring 4.3 аннотация @Autowired для конструктора больше не требуется, если целевой компонент определяет
только 1 конструктор.

@Autowired(required = false) - означает, что Spring может не генерить исключение, если будет сбой при внедрении.

По умолчанию Spring распознает объекты для вставки по ТИПУ. Если в контейнере доступно более 1 бина с нужным типом,
будет выброшено исключение.

Для избежания этого, поможет аннотация @Qualifier("[имя поля бина]").

### 11. Расскажите про аннотацию @Resource?

`@Resource` может применяться к классам, полям и методам

```
@Resource(name = "fileName")
private File defaultFile;
```

@Resource пытается получить зависимость

- сперва по имени
    - Имя берется из аннотируемого поля или сеттера, либо из параметра name. При аннотировании класса имя не
      извлекается, поэтому оно должно быть указано явно.
- потом по типу
- затем по описанию @Qualifier

Указав данную аннотацию у полей или методов с аргументом `name`

### 12. Расскажите про аннотацию @Inject ?

### 13. Расскажите про аннотацию @Lookup ?

Метод, помеченный @Lookup, говорит Spring возвращать экземпляр типа возвращаемого значения метода. 

Обычно используется бином singleton в связке с бином prototype

### 14. Как работает инъекция прототипа в singleton ?

Допустим ситуацию, когда в singleton-компонент внедряется зависимость со scope prototype - когда будет создан её объект?

Если добавить к определению бина аннотацию `@Scope(SCOPE_PROTOTYPE)` и использовать этот бин в синлтоне через аннотацию
`@Autowired` - будет создан только 1 объект.

Простой способ получать новый объект при каждом обращении - отказаться от `@Autowired` и доставать его из контекста
вручную, вызывая `context.getBean(MyPrototype.class)`.

Воспользоваться автоматическим внедрением зависимостей можно через внедрение метода (паттерн "Команда"). Внедряется не
сам объект, а производящий его метод.

**Более красивый декларативный способ - правильно настроить определение бина.**

В аннотации `@Scope` кроме самого `scopeName` доступен параметр `proxyMode`.

По умолчанию его значение `NO` - прокси не создается. Но если указать `INTERFACES` или `TARGET_CLASS`, то
под `@Autowired` будет внедряться не сам объект, а его сгенерированный фреймворком прокси.

И когда проксируемый бин имеет `scope prototype`, то объект внутри прокси будет пересоздаваться при каждом обращении.

(Дописать пример!!!)

### 15. Можно ли вставить бин в статическое поле? Почему ?

### 16. Расскажите про аннотации @Primary и @Qualifier ?

### 17. Как заинжектить примитив ?

Внедрить в поле примитив можно с помощью `@Value` на уровне полей или конструктора / метода.

Понадобится файл свойств (*.properties | *.yaml : файлы, желательно, должны лежать в папке /resources), чтобы определить
значение, которое нужно внедрить аннотацией `@Value`.

Сначала в классе конфигурации нужно указать аннотацию @PropertySource с именем файла свойств.

Если по каким-либо причинам значение не подтянутся, можно указать значения по умолчанию:

```
@Value("${some.value.from.file:default value}")
private String defaultValue;
```

Если в значении прописать значения через запятую, то они будут внедрены как массив значений:

```
values.of.properties:
    array.of.value=age,num,day

SomeClass.java:
    @Value("${array.of.value}")
    private String[] arrayOfString;
```

@Value with SpEL

Можно внедрять значения с помощью Spring Expression Language:

```
@Value("#{systemProperties['property']}")
private String spelValue;
```

Со значением по умолчанию:

```
@Value("#{systemProperties['property'] ? : 'default value'}")
private String spelValue;
```

Значение из поля бина:

```
@Value("#{someBean.property}")
private Integer valueProperty;
```

Значение из списка:

```
@Value("#{'$(listOfValues)'.split(',')}")
private List<String> listValues;
```

@Value with Map

Внедрение Map с помощью @Value:

```
values.as.properties:
    value.of.map={age: '10', day: '31', mounth: '02'}

@Value("#{'$(listOfValues)'.split(',')}")
private Map<String, Integer> mapOfValues;
```

Внедрение значения по ключу:

```
values.as.properties:
    value.of.map={age: '10', day: '31', mounth: '02'}

@Value("#{$(value.of.map).age}")
private Integer mapOfValues; // 10
```

Если значение может отсутствовать в map, можно прописать более безопасное выражение:

```
@Value("#{$(value.of.map)['unknowKey']}")
private Integer unknowMapKey;
```

Значение map, если неизвестно, существует оно или нет:

```
@Value("#{$(unknowMap : {key1 : '1', key2 : '2'})}")
private Map<String, Integer> unknowMap;

@Value("#{$(value.of.map)['unknowKey'] ? : 5}")
private Integer unknowMapKeyWithDefaultValue;
```

Отфильтрованная map перед внедрением:

```
@Value("#{$(value.of.map).?[value > '1']}")
private Map<String, Integer> filteredMap;
```

Внедрение всех существующих системных свойств:

```
@Value("#{value.of.map}")
private Map<String, String> systemPropertiesMap;
```

@Value with Constructor

Можно внедрить значения в конструктор, если они не найдены, то будут внедрены значения по умолчанию

```
@Component
@PropertySource("classpath:values.properties")
public class PriorityProvider {

    private String priority;
    
    @Autowired
    public PriorityProvider(@Value("${priority:normal}") String priority) {
        this.priority = priority;
    }
}
```

@Value with Constructor

```
@Component
@PropertySource("classpath:values.properties")
public class PriorityProvider {

    private List<String> values = new ArrayList<>();
    
    @Autowired
    public void setValues(
                @Value("#{'${listOfValues}'.split(',')}") List<String> values) {
        this.values.addAll(values);
    }
}
```

### 18. Как заинжектить коллекцию ?

### 19. Расскажите про аннотацию @Conditional ?

Иногда необходимо иметь возможность отключать весь класс @Configuration, @Component или отдельные методы @Bean, в
зависимости от каких либо условий.

@Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия
соответствуют. Может применяться:

- над классами прямо или косвенно аннотируемыми @Component, включая классы @Configuration;
- над методами Bean;
- как мета-аннотация при создании собственных аннотаций-условий.

Условия проверяются непосредственно перед тем, как должен быть зарегистрирован BeanDefinition компонента, и, они (
условия) могут помешать регистрации данного BeanDefinition.

Поэтому, нельзя допускать, что бы компоненты взаимодействовали с еще не существующими бинами, только с их
BeanDefinition.

Условия определяются в специально создаваемых классах, которые имплементируют функциональный интерфейс Condition с
единственным методом:

```
boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {}
```

Создав свой класс и переопределив метод matches с нашей логикой, необходимо передать класс в @Conditional в качестве
параметра:

```
@Configuration
@Conditional(MyConditional.class)
public class MyConfiguration {}
```

Для проверки нескольких условий необходимо передать несколько классов

```
@Configuration
@Conditional(MyConditionalFirst.class, MyConditionalSecond.class)
public class MyConfiguration {}
```

Если над классом @Configuration стоит @Conditional(), то условия распространяются на все методы @Bean, @Import,
@ComponentScan.

Для более детальной настройки классов, аннотированных @Configuration, предлагается использовать интерфейс
ConfigurationCondition.

В 1 классе, одно условие. Для создания более сложных условий можно использовать классы:

- AnyNestedCondition
- AllNestedCondition
- NoneNestedCondition

Другие варианты для прописывания условий:

![](/Users/egorskoblikov/IdeaProjects/iconsoft/MyWiki01/img/img.png)

### 20. Расскажите про аннотацию @Profile ?

Профили - ключевая особенность в Spring, позволяющая относить бины к разным логическим группам, test, prod, dev.

Можно активировать разные профили в разных средах, что бы загрузить те бины, которые нужны. С помощью @Profile можно
отнести бин к нужному профилю.

@Profile используется на уровне класса и метода:

```
@Component
@Profile("dev")
public class DevUtilsConfig {}
```

Если профиль бина не определен, то по умолчанию он "default".

Можно установить профиль по умолчанию:

```
spring.profiles.default=...
```

В Spring Boot можно иметь 1 файл настроек application.properties для всех профилей, а также, каждый файл на каждый
профиль:
application-dev.properties
application-tst.properties
application-preprod.properties
application-prod.properties

### 21. Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать ?

BeanFactory - интерфейс, предоставляет механизм конфигурации, способный управлять объектами любого типа, предоставляет
инфраструктуру конфигурации и основные функциональные возможности. BeanFactory отвечает за создание и хранение всех
объектов (синглтонов).

ApplicationContext расширяет BeanFactory и полностью реализует его функционал, добавляя специфические функции:
- предоставление информации о конфигурации приложения, 
- АОП 
- является источником интернационализации i18n 
- обработки событий 

ApplicationContext доступен только для чтения во время выполнения. 

ApplicationContext предоставляет: 
- фабричные методы бина для доступа к компонентам приложения
- возможности выгружать файловые ресурсы в общем виде
- возможность публиковать события и регистрировать обработчики на них
- возможность работы с сообщениями с поддержкой интернационализации internationalization
- наследование от родительского контекста

BeanFactory / ApplicationContext
- ручная регистрация BeanPostProcessor / автоматическая регистрация BeanPostProcessor
- поддержка ленивой загрузки / автоматическое создание бина при запуске контейнера,
- не поддерживает i18n / поддерживает i18n
- не поддерживает несколько файлов конфигурации / поддерживает
- существует для обратной совместимости / 
-  / Публикация Application Event - для зарегистрированных бинов как слушателей 

### 22. Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy ?



### 23. Расскажите про скоупы бинов? Какой скоуп используется по умолчанию ?

### 24. Расскажите про аннотацию @ComponentScan ?

### 25. Как спринг работает с транзакциями ?

### 26. Расскажите про аннотацию @Transactional ?

### 27. Расскажите про аннотации @Controller и @RestController. Чем они отличаются ?

### 28. Как вернуть ответ со своим статусом (например, 213) ?

### 29. Что такое ViewResolver ?

### 30. Чем отличаются Model, ModelMap и ModelAndView ?

### 31. Расскажите про паттерн Front Controller, как он реализован в Spring ?

### 32. Что такое AOP? Как реализовано в спринге ?

### 33. PROXY что это, для чего и как применяется в Spring ?

### 34. В чем разница между Filters, Listeners and Interceptors ?

### 35. Можно ли передать в запросе один и тот же параметр несколько раз? Как ?

### 36. Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются ?

### 37. Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно ?

### 38. Какие задачи решает Spring Data? ?

### 39. Какова иерархия интерфейсов/классов репозитория в Spring Data JPA ?

### 40. Как преодолеть проблему блокирующих вызовов ?

### 41. Как вызвать транзакционный метод из того же класса ?

### 42. Когда отрабатывает @Autowired а когда @Transactional? почему? Почему нельзя отработать @Transactional в другом методе ?

### 43. Структура HTTP запроса, ответа ?

Каждый HTTP запрос / ответ состоит из 3 частей:

- Стартовая строка - определяет ти сообщения

- Заголовки - характеризуют тело сообщения, параметры передачи и прочие сведения

- Тело сообщение - данные сообщения

### 44. HTTP методы ?

REST API основана на запросах или командах, каждая из которых выполняет свою задачу

- Метод GET - запрос данных с сервера
- Метод POST - отправка данных на сервер с целью создания нового ресурса по указанному сервером URL-адресу
- Метод PUT - отправка данных на сервер с целью создания нового ресурса по указанному клиентом URL-адресу
- Метод DELETE - запрос на удаление ресурса с сервера
- Метод OPTIONS - возврат методы запросов, поддерживаемых службой
- Метод HEAD - возврат мета информации, например заголовки ответа.
- Метод PATCH - запрос частичного изменения ресурса на сервере

### 45. Ключевое отличие методов POST и GET ?

GET :                                       POST:

- Передаваемая информация содержится в URL. - хранится в теле запроса
- Ограничен максимальной длиной. - не ограничен максимальной длиной
- Не поддерживает передачу бинарных данных. - поддерживает передачу бинарных данных
- Можно поделиться ссылкой. - поделиться ссылкой нельзя
- Используется для получения информации. - используется для добавления ресурса

### 46. REST стиль ?

REST API (Representational State Transfer API) - архитектурный стиль взаимодействия компонентов распределенного web
приложения.

REST означает передачу репрезентативного состояния.

Архитектурные ограничения REST:

- единый интерфейс
- клиент-сервер
- клиент и сервер не хранит состояние друг друга. Сервер обрабатывает каждый запрос как новый.
- кэшируемость
- многоуровниевая система

### 47. Идемпотентность: что это такое, методы ?

Идемпотентность - свойство операции выполняться сколь угодно раз не меняя состояния. Результат может меняться.

**Безопасный запрос** - запрос не меняющий состояния.
**Идемпотентный запрос** - запрос, эффект которого от многократного выполнения равен эффекту от однократного выполнения.

### 48. Как метод пост сделать идемпотентным ?

Добавить в метод PUT проверку

### 49. ?

### 40. ?

### 41. ?

### 42. ?

### 43. ?

### 44. ?

### 45. ?

### 46. ?

### 47. ?

### 48. ?

### 49. ?

### 50. ?

### 51. ?

### 52. ?

### 53. ?

### 54. ?

### 55. ?

### 56. ?

### 57. ?

### 58. ?

### 59. ?

### 39. ?